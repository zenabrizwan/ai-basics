# -*- coding: utf-8 -*-
"""21l5640lab4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12Vp8FlBl4yD3rUlTyj9sABsWTJMwr9z2

question 1
"""

import numpy as np
def read_cube_from_file(filen):

    with open(filen, 'r') as f:
        lines = f.readlines()
        cube = [[int(char) for char in line.strip()] for line in lines]
    return np.array(cube, dtype=int)

cube_array = read_cube_from_file('cube.txt')

def dfs(cube, start_pos, goal_pos, visited=None):

    if visited is None:
        visited = set()
    visited.add(start_pos)

    if start_pos == goal_pos:
        return [start_pos]

    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):
        new_pos = (start_pos[0] + dx, start_pos[1] + dy)
        if 0 <= new_pos[0] < cube.shape[0] and 0 <= new_pos[1] < cube.shape[1] \
           and cube[new_pos[0]][new_pos[1]] == 0 and new_pos not in visited:
            path = dfs(cube, new_pos, goal_pos, visited.copy())
            if path:
                return [(start_pos), *path]

    return None

from collections import deque

def bfs(cube, start_pos, goal_pos):


    queue = deque([(start_pos, [])])
    visited = set()

    while queue:
        pos, path = queue.popleft()
        if pos == goal_pos:
            return path + [pos]

        if pos not in visited:
            visited.add(pos)
            for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                new_pos = (pos[0] + dx, pos[1] + dy)
                if 0 <= new_pos[0] < cube.shape[0] and 0 <= new_pos[1] < cube.shape[1] \
                   and cube[new_pos[0]][new_pos[1]] == 0 and new_pos not in visited:
                    queue.append((new_pos, path + [pos]))

    return None

cube = read_cube_from_file('cube.txt')
start_pos = (0, 0)
goal_pos = (6, 6)

dfs_path = dfs(cube, start_pos, goal_pos)
bfs_path = bfs(cube, start_pos, goal_pos)

if dfs_path:
    print("DFS path:", dfs_path)
else:
    print("DFS: No path found.")

if bfs_path:
    print("BFS path:", bfs_path)
else:
    print("BFS: No path found.")

"""question 2"""

from heapq import heappush, heappop

def ucs(graph, start, goal):


  frontier = [(0, start, [])]
  explored = set()

  while frontier:

    cost, node, path = heappop(frontier)


    if node == goal:
      return cost, path + [node]


    explored.add(node)

    for neighbor, weight in graph[node].items():
      if neighbor not in explored:
        new_cost = cost + weight
        new_path = path + [node]

        if neighbor in [n[1] for n in frontier]:
          for i, (f_cost, f_node, f_path) in enumerate(frontier):
            if f_node == neighbor and new_cost < f_cost:
              frontier[i] = (new_cost, neighbor, new_path)
              break
        else:
          heappush(frontier, (new_cost, neighbor, new_path))

  return None

graph = {
  'A': {'B': 2, 'C': 4},
  'B': {'A': 2, 'D': 3, 'E': 5},
  'C': {'A': 4, 'D': 1},
  'D': {'B': 3, 'C': 1, 'E': 2},
  'E': {'B': 5, 'D': 2},
}

start = 'A'
goal = 'E'

shortest_path, cost = ucs(graph, start, goal)

if shortest_path:
  print(f"Shortest path from {start} to {goal}: {cost} with cost {shortest_path}")
else:
  print(f"No path found from {start} to {goal}")

"""question 3"""

from heapq import heappush, heappop

def read_cube(filename):
  cube = []
  with open(filename) as f:

    for line in f:
      row = [int(x) for x in line.strip().split()]
      cube.append(row)
  return cube

def find_goal(cube):
  for x in range(len(cube)):
    for y in range(len(cube[x])):
      for z in range(len(cube[x][y])):
        if cube[x][y][z] == "+":
          return (x, y, z)
  raise ValueError("Goal not found in cube!")

def is_valid_move(cube, pos, dx, dy, dz):
  new_x, new_y, new_z = pos[0] + dx, pos[1] + dy, pos[2] + dz
  return 0 <= new_x < len(cube) and 0 <= new_y < len(cube[new_x]) and 0 <= new_z < len(cube[new_x][y]) and cube[new_x][new_y][new_z] != 1

def get_neighbors(cube, pos):
  neighbors = []
  for dx, dy, dz in [(0, 1, 0), (0, -1, 0), (1, 0, 0), (-1, 0, 0), (0, 0, 1), (0, 0, -1)]:
    if is_valid_move(cube, pos, dx, dy, dz):
      neighbors.append((cube, (pos[0] + dx, pos[1] + dy, pos[2] + dz)))
  return neighbors

def heuristic(cube, goal):
  # Manhattan distance heuristic considering short walls as cost 1
  return sum(abs(c1 - c2) + (c1 == 2) for c1, c2 in zip(cube.flatten(), goal.flatten()))

def astar(cube, start, goal):
  frontier = [(0, start)]  # (cost, state)
  explored = set()
  came_from = {}

  while frontier:
    cost, state = heappop(frontier)
    current_cube, current_pos = state
    if current_pos == goal:
      path = [current_pos]
      while current_pos in came_from:
        current_pos = came_from[current_pos]
        path.append(current_pos)
      path.reverse()
      return path, cost

    if state in explored:
      continue

    explored.add(state)

    for neighbor_cube, neighbor_pos in get_neighbors(current_cube, current_pos):
      new_cost = cost + 1 + (current_cube[current_pos[0]][current_pos[1]][current_pos[2]] == 2)
      if neighbor_pos not in explored and (neighbor_pos not in [n[1] for n in frontier] or new_cost < frontier[[n[1] for n in frontier].index(neighbor_pos)][0]):
        heappush(frontier, (new_cost + heuristic(neighbor_cube, goal), (neighbor_cube, neighbor_pos)))
        came_from[neighbor_pos] = current_pos

  return None, None

cube = read_cube("cube.txt")
start = (0, 0, 0)  # Replace with actual start position
goal = find_goal(cube)

path, cost = astar(cube, start, goal)

if path:
  print(f"Path: {path} with cost {cost}")
else:
  print("No path found!")