# -*- coding: utf-8 -*-
"""ailab6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-GgnOxiS4lv0iHxeCUwocywhVGfUyOMe
"""

import random

def initial_state(n):

    return [random.randint(0, n-1) for _ in range(n)]

def num_attacking_queens(state):
    """
    Calculate the number of pairs of queens that are attacking each other.
    """
    n = len(state)
    attacks = 0
    for i in range(n):
        for j in range(i+1, n):
            if state[i] == state[j] or abs(state[i] - state[j]) == abs(i - j):
                attacks += 1
    return attacks

def get_neighbors(state):
    """
    Generate all possible neighbors of the current state.
    """
    neighbors = []
    n = len(state)
    for i in range(n):
        for j in range(n):
            if j != state[i]:
                neighbor = list(state)
                neighbor[i] = j
                neighbors.append(neighbor)
    return neighbors

def hill_climbing(n, max_iterations=1000):
    """
    Hill climbing algorithm to solve the N Queens problem.
    """
    current_state = initial_state(n)
    current_attacks = num_attacking_queens(current_state)

    for _ in range(max_iterations):
        neighbors = get_neighbors(current_state)
        next_state = None
        next_attacks = float('inf')

        for neighbor in neighbors:
            neighbor_attacks = num_attacking_queens(neighbor)
            if neighbor_attacks < next_attacks:
                next_state = neighbor
                next_attacks = neighbor_attacks

        if next_attacks >= current_attacks:
            # Local optimum reached
            break

        current_state = next_state
        current_attacks = next_attacks

    return current_state

n = 8
solution = hill_climbing(n)
for row in solution:
    print(' '.join(['Q' if i == row else '-' for i in range(n)]))